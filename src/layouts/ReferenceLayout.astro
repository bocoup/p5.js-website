---
import { type CollectionEntry } from "astro:content";
import BaseLayout from "./BaseLayout.astro";
import {
  normalizeReferenceRoute,
  getRefEntryTitleConcatWithParen,
} from "@pages/_utils";
import { categories } from "../content/reference/config";

type ReferenceEntry = CollectionEntry<"reference">;

interface Props {
  title: string;
  entries: ReferenceEntry[];
}

function strCompare(a: string, b: string) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}

const { entries } = Astro.props;
const categoryData = categories.map((category) => {
  // Get all reference entries in the module
  const directEntries = entries.filter((e) => e.data.module === category);

  // Get the names of all submodules
  const subcats = [
    ...new Set(
      directEntries
        // Ignore classes here, they will be added later
        .filter((e) => e.data.submodule && !e.data.isConstructor)
        .map((e) => e.data.submodule)
    ).values(),
  ].sort();

  // Find the classes in this module. These will be turned into subcategories.
  const classes = directEntries
    .filter((e) => e.data.isConstructor && e.data.module === category)
    .sort((a, b) => strCompare(a.data.title, b.data.title));

  // Return the data for each subcategory
  const subcatData = [
    {
      name: undefined,
      entry: undefined,
      entries: directEntries.filter(
        (e) =>
          !e.data.submodule &&
          !e.data.isConstructor &&
          !classes.some((c) => c.data.title === e.data.class)
      ),
    },
    ...subcats.map((subcat) => ({
      name: subcat,
      entry: undefined,
      entries: directEntries.filter(
        (e) =>
          e.data.submodule === subcat &&
          !e.data.isConstructor &&
          e.data.description !== "" &&
          !classes.some((c) => c.data.title === e.data.class)
      ),
    })),
    ...classes.map((entry) => ({
      name: entry.data.title,
      entry, // Include the class entry itself so we can make the header a link
      entries: directEntries.filter((e) => e.data.class === entry.data.title),
    })),
  ];

  return {
    name: category,
    subcats: subcatData,
  };
});
---

<BaseLayout title="Reference">
  {
    categoryData.map((category) => (
      <div class="my-md pb-2xl border-b border-type-color">
        <h2>
          {category.name}
          <a id={category.name} />
        </h2>
        {category.subcats.map((subcat) => (
          <div>
            {subcat.name && (
              <div class="my-lg">
                {subcat.entry ? (
                  <h3>
                    <a
                      id={subcat.name}
                      href={`/reference/${normalizeReferenceRoute(subcat.entry.id)}`}
                    >
                      {subcat.name}
                    </a>
                  </h3>
                ) : (
                  <h3>
                    {subcat.name}
                    <a id={subcat.name} />
                  </h3>
                )}
              </div>
            )}
            <div class="content-grid">
              {subcat.entries.map((refEntry) => (
                <div class="col-span-3 w-full overflow-hidden">
                  <a
                    href={`/reference/${normalizeReferenceRoute(refEntry.id)}`}
                    class="text-body-mono"
                  >
                    {/* Needs set:html to render the entries for e.g. the > operator */}
                    <span
                      set:html={getRefEntryTitleConcatWithParen(refEntry)}
                    />
                  </a>
                  <p>
                    {refEntry.data.description
                      .replace(/<[^>]*>/g, "")
                      .split(/\.(\s|$)/, 1)[0] + "."}
                  </p>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    ))
  }
</BaseLayout>
